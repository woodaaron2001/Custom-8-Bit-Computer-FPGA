
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================
`timescale 1us/ 100 ns
module customComputer
#(
    parameter ROM_FILENAME      = "../../roms/rom.hex",
	 parameter RAM_FILENAME      = "../../roms/emptyRam.hex")
	 
(

	//////////// CLOCK //////////
	input 		          		CLOCK_50,
	//input 		          		CLOCK2_50,
	//input 		          		CLOCK3_50,
	//inout 		          		CLOCK4_50,

	//////////// SDRAM //////////
	//output		    [12:0]		DRAM_ADDR,
	//output		     [1:0]		DRAM_BA,
	//output		          		DRAM_CAS_N,
	//output		          		DRAM_CKE,
	//output		          		DRAM_CLK,
	//output		          		DRAM_CS_N,
	//inout 		    [15:0]		DRAM_DQ,
	//output		          		DRAM_LDQM,
	//output		          		DRAM_RAS_N,
	//output		          		DRAM_UDQM,
	//output		          		DRAM_WE_N,

	//////////// SEG7 //////////
	//output		     [6:0]		HEX0,
	//output		     [6:0]		HEX1,
	//output		     [6:0]		HEX2,
	//output		     [6:0]		HEX3,
	//output		     [6:0]		HEX4,
	//output		     [6:0]		HEX5,

	//////////// KEY //////////
	//input 		     [3:0]		KEY,
	input 		          		RESET_N,

	//////////// LED //////////
	output reg		     [9:0]		LEDR,
	

	//////////// PS2 //////////
	inout 		          		PS2_CLK,
	//inout 		          		PS2_CLK2,
	inout 		          		PS2_DAT,
	//inout 		          		PS2_DAT2,

	//////////// microSD Card //////////
	//output		          		SD_CLK,
	//inout 		          		SD_CMD,
	//inout 		     [3:0]		SD_DATA,

	//////////// SW //////////
	//input 		     [9:0]		SW,

	//////////// VGA //////////
	output		     [3:0]		VGA_B,
	output		     [3:0]		VGA_G,
	output		          		VGA_HS,
	output		     [3:0]		VGA_R,
	output		          		VGA_VS
);



//=======================================================
//  REG/WIRE declarations
//=======================================================
	
	wire z80_write;
	wire z80_read;

	wire [7:0] data_bus;
	wire [15:0] address_bus;

	
	//Memory map Chip select layout
	wire [7:0] rom_out;
	wire rom_cs = (address_bus >= 16'h0000) && (address_bus <= 16'h2FFF); 
	
	wire [7:0] ps2_out;
	wire ps2_cs = (address_bus == 16'h3000); 

	wire [7:0] cram1_out;
	wire cram1_cs = (address_bus >= 16'h3001) && (address_bus <= 16'h3006); 
	
	wire [7:0] cram2_out;
	wire cram2_cs = (address_bus >= 16'h3007) && (address_bus <= 16'h300C); 
	
	wire [7:0] cram3_out;
	wire cram3_cs = (address_bus >= 16'h300D) && (address_bus <= 16'h3012); 
	
	wire [7:0] cram4_out;
	wire cram4_cs = (address_bus >= 16'h3013) && (address_bus <= 16'h3018); 

	wire [7:0] vramL1_out;
	wire vramL1_cs = (address_bus >= 16'h3019) && (address_bus <= 16'h34C8);

	wire [7:0] vramL2_out;
	wire vramL2_cs = (address_bus >= 16'h34C9) && (address_bus <= 16'h3978); 
	
	wire [7:0] ram_out;
	wire ram_cs = (address_bus >= 16'h3979) && (address_bus <= 16'hFFFF);

	wire [9:0] LEDR_wire;
	
//=======================================================
//  Structural coding
//=======================================================

	ps2 ps2_inst(
		.PS2_CLK(PS2_CLK),
		.PS2_DAT(PS2_DAT),
		.PS2OUT(ps2_out),
		.LEDR(LEDR_wire)
	);

	always@(posedge PS2_CLK) begin
		LEDR <= LEDR_wire;
	end
	
	z80_top_direct_n inst1 
	 (.CLK(vga_clk),
	  .nWR(z80_write),
	  .nRD(z80_read),
	  
	  .nWAIT(1),
     .nINT(1),
     .nNMI(1),
     .nRESET(1),
     .nBUSRQ(1),
	  .D(data_bus),
	  .A(address_bus)
	 );
	
	 ram #(
		.RAM_FILENAME(RAM_FILENAME)
	) ram_inst(
		.clk(vga_clk),
	  .addr(address_bus - 16'h3979),
	  .data_in(data_bus),
	  .write_en(~z80_write & ram_cs),
	  .data_out(ram_out)
	);
	 
	rom #(
		.ROM_FILENAME(ROM_FILENAME)
	) rom_inst(
		.addr(address_bus),
		.data(rom_out)
	);
	
	vga_pll clkControl(
		 	.refclk(CLOCK_50),
			.rst(~RESET_N),
			.outclk_0(vga_clk)	
	);
	
	
	vgaController vC (
		.vga_clk(vga_clk),
		.cpu_clk(vga_clk),
		.rst(~RESET_N),
		.data_bus(data_bus),
		.address_bus(address_bus),
		.z80_write(z80_write),
		.vramL1_cs(vramL1_cs),
		.vramL2_cs(vramL2_cs),
		.cram1_cs(cram1_cs),
		.cram2_cs(cram2_cs),
		.cram3_cs(cram3_cs),
		.cram4_cs(cram4_cs),
		
		.h_sync(VGA_HS),
		.v_sync(VGA_VS),
		.v_red(VGA_R),
		.v_green(VGA_G),
		.v_blue(VGA_B),
		.vramL1_out(vramL1_out),
		.vramL2_out(vramL2_out),
		.cram1_out(cram1_out),
		.cram2_out(cram2_out),
		.cram3_out(cram3_out),
		.cram4_out(cram4_out)
	);
	
	//since databus on z80 is an inout wire, data flows both ways
	//Chip selects are used in conjunction with Hi Z state to transfer data
	assign data_bus = (rom_cs & (~z80_read)) ? rom_out :
						   (ram_cs & (~z80_read)) ? ram_out :
						   (vramL1_cs & (~z80_read)) ? vramL1_out :
						   (vramL2_cs & (~z80_read)) ? vramL2_out :
						   (cram1_cs & (~z80_read)) ? cram1_out :
							(cram2_cs & (~z80_read)) ? cram2_out :
							(cram3_cs & (~z80_read)) ? cram3_out :
							(cram4_cs & (~z80_read)) ? cram4_out :
							(ps2_cs & (~z80_read)) ? ps2_out:
						   {8{1'bz}};
						  
						  
	
	
	//assign data_bus = (rom_cs & (~z80_read)) ? rom_out : ((ram_cs & (~z80_read)) ? ram_out :{8{1'bz}});
	
	
endmodule